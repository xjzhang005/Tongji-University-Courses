树的重构
描述
树木在计算机科学中有许多应用。 也许最常用的树是二叉树，但也有其他的同样有用的树类型。 其中一个例子是有序树（任意节点的子树是有序的）。 
每个节点的子节点数是可变的，并且数量没有限制。 一般而言， 有序树由有限节点集合T组成，并且满足：

    1.其中一个节点置为根节点，定义为root(T);

    2.其他节点被划分为若干子集T1,T2,...Tm,每个子集都是一个树.

同样定义root(T1),root(T2),...root(Tm)为root(T)的孩子，其中root(Ti)是第i个孩子。节点root(T1),...root(Tm)是兄弟节点。

通常将一个有序树表示为二叉树是更加有用的，这样每个节点可以存储在相同内存空间中。有序树到二叉树的转化步骤为：

    1.去除每个节点与其子节点的边

    2.对于每一个节点，在它与第一个孩子节点（如果存在）之间添加一条边，作为该节点的左孩子

    3.对于每一个节点，在它与下一个兄弟节点（如果存在）之间添加一条边，作为该节点的右孩子

如图所示：

   0                       0

 / | \                    /

1  2  3      ===>        1

  / \                     \

 4   5                     2

                          / \

                         4   3

                          \

                           5

在大多数情况下，树的深度（从根节点到叶子节点的边数的最大值）都会在转化后增加。这是不希望发生的事情因为很多算法的复杂度都取决于树的深度。

现在，需要你实现一个程序来计算转化前后的树的深度。


输入
输入由多行组成，每一行都是一棵树的深度优先遍历时的方向。其中d表示下行(down)，u表示上行(up)。
例如上面的树就是dudduduudu,表示从0下行到1,1上行到0,0下行到2等等。输入的截止为以#开始的行。
可以假设每棵树至少含有2个节点，最多10000个节点。

输出
对每棵树，打印转化前后的树的深度，采用以下格式 Tree t: h1 => h2。其中t表示样例编号(从1开始)，h1是转化前的树的深度，h2是转化后的树的深度。


样例输入
dudduduudu

ddddduuuuu

dddduduuuu

dddduuduuu

#
样例输出
Tree 1: 2 => 4

Tree 2: 5 => 5

Tree 3: 4 => 5

Tree 4: 4 => 4


数据范围
行数<5000, 总字符数<2,000,000
